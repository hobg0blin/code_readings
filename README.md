# Become a Better Programmer In Ten Million Easy Steps

Work in progress as I compile all the links I've bookmarked, downloaded, etc. over the years. 

This is a repository of links and files that I have either found useful in my attempts to become a 1x programmer, or am saving for future reference. 

### Some thoughts on "becoming a better programmer"
I have been writing code professionally since 2016. At no point during the following years have I felt like I knew what I was doing or that I am a "good" programmer. When I started, I kind of just followed what they taught me in my bootcamp, and then whatever people on Hacker News told me to do. Eventually I learned enough to be able to do the job without handholding, and since then I've followed no particular pattern in my "code journey". A lot of the guides and reading lists out there are good, but there are too many things to learn and I will probably forget most of them. I have no desire to become a 10x programmer, but someday I at least hope to feel confident that I'm okay at it: what I call the 1x programmer. 

Trying to find a comprehensive program to make you a good programmer is kind of a lost cause. Any attempt at searching "how to become a better programmer" quickly becomes overwhelming, there are a hundred different languages/design patterns/concepts to learn, and no matter how much time you spend reading about code there will be someone out there who knows more than you. Getting better at code is a Sisyphean task, and anyone telling you to follow XYZ steps to become a good programmer is probably either trying to sell you something or operating off of confirmation bias: there's no one right way to do any of this, and the path to becoming, I dunno, someone who writes compilers vs. a really good front-end developer will be wildly different. 

Because of all of this, I spend a lot of time a) feeling like an idiot and b) "fucking around and finding out". The best way to learn is by doing, and the best code is code that works. But when I decide I want to "level up" or learn something new without the pressure of a deadline, I feel a bit rudderless. The only way to not be totally paralyzed, for me, is to just find things that make sense and are interesting to me and go from there. This has made me a jack of all trades and master of none, but I've learned some cool stuff and am still getting paid to write code, so I assume I'm doing something right. With that attitude in mind, this is not a structured guide, nor a comprehensive list, but just things that I, personally, think are cool or useful that I've found when trying to teach myself new things. Maybe you'll find it useful too.

## Table of Contents

- [Testing](#testing)
- [Vim](#vim)
- [Frontend](#frontend)
- [Python](#python)

## General Programming Advice
- [The grug-brained dev](https://grugbrain.dev/) - It's a bit of a cute conceit but all the advice in here is gold, and Carson made [HTMX](https://htmx.org) so he's doing something right.

## Testing

I have only had one job where I actually had to write tests (as a research assistant in grad school), but I often fantasize about being someone who actually uses them.

- [The Well-Maintained Test](https://adamj.eu/tech/2021/11/04/the-well-maintained-test/)
- [The Joel Test](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/)

## Vim

I am not what I would consider a Vim power user, but I have been using it daily for years. I used it in the terminal as my daily driver for most of that period, but more recently have been working with neovim for VSCode. You probably don't *need* to learn Vim to be a good programmer, but it's fucking cool and it *does* make you a faster programmer if you take the time to learn it.

- [VSCode NeoVim Setup](https://ianchanning.wordpress.com/2023/02/21/vscode-neovim-setup/)
- [Nvim Cheat Sheet](vim/nvim_cheatsheet.png)
- [Practical Vim](<vim/Practical Vim Edit Text at the Speed of Thought.pdf>)

## Frontend

Frontend is an absolute unstable nightmare, but it's also probably the thing I've spent the most time being paid to do. I've written jQuery, Bacon.js (don't ask), React, Svelte, and plenty of VanillaJS professionally. As of this writing (2024), I think Svelte is probably my favorite of the big frameworks, but I'm trying to focus on whatever the most "future-proof" path forward is. Once you've been doing this long enough you start to get annoyed by how fast it moves and I'd rather write code that won't require a build process and will probably still run in ten years. 

- [Going buildless: ES modules](https://modern-web.dev/guides/going-buildless/es-modules/)
- [Reckoning Part 3: Development without constraints isn't engineering](https://infrequently.org/2024/08/caprock/) - whole series is good, but this one hit the hardest for me.
- [Are SPAs ruining the internet?](https://htmx.org/essays/a-response-to-rich-harris/)

## Python

I like Python a lot.

- [PEP-0008](https://peps.python.org/pep-0008/#introduction) - Embarrassingly enough, I wrote Python for like 5 years before actually reading PEP 8. This is another one of those things that I probably wouldn't have understood early on in the learning process, but it's a pretty great place to start understanding Python's design philosophy.

